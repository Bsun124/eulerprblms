# eulerprblms
Hi, this is Lab 4 - Euler Problems for Bill Sun. Here is the Journal for the work time. 

December 10th: 9:06 AM - 9:50 One Hour
Entry: I started doing the first problem and got stuck on creating the function for the multiples of threes and fives. Later I decided to use an or statement, after I determined that OR would not prevent any multiple counts. Nearly finished first problem with an hour of pseudocoding. I encountered many roadblocks on this first Project Euler Problem, due to my lack of accuracy when doing arithmetic with a computer. The real answer may be 1 off from my solution, which means that there are certainly bad variable placements. The sum is easy to calculate with the help of a += operations sign. 

December 10th: 3:16 PM - 4:00 PM One Hour
I finished the first problem by using range instead of a list or other difficult iteration programming. For the second question, I know that creating a defined reading frame is the main function used to find the Fibonacci numbers. I set multiple variables, two equal to zero, and two equal to 1 in order to initialize the reading frame. Besides the creation of the reading frame, writing the while loop was easy, and eventually I was inspired to create an a-b-temp variable system that transferred positions for the iterations. Although the concept was clear, I faced many roadblocks: I spent way too much time on errors and searching up basic range functionality. I finished number 2 and left the third question up for the next time. 

December 14th: 4:00 PM - 4:56 PM One Hour 
Today I worked on problems three and four. The first problem involved finding the largest prime factor of a very large number. I decided to make a brute force program that came with a little bit of intelligence. I knew that computing speed could be increased by 50% if I created a While loop up until the square root of the large number, so there would not be duplicate factors that are simply on different sides of the equation. However, I did have a bit of trouble creating the rest of the program, because I did not know an efficient way to break down composite numbers and store them for later use. I did finish the problem around 30 minutes later. I spent the rest of the hour doing number, which was the palindromic number creation. I discovered a simple but long program I could use that heavily involved lists. I created two helper functions that reverses numbers, and the other checks whether or not the string is a palindrome. The code is nearly finished, but left for tomorrow to complete. 

December 23th: 12:12 PM - 1:00 PM Two Hours
Using a layered for loop, I was able to create lists of palindrome products. The code consisted mostly of brute force, and the runtime was half a second (quite a lot of time for a computer). Ten minutes later, I started working on finding the lcm of twenty numbers. I initially created a program that would compute the lcm of multiple numbers. After a while, I encountered some problems: efficient lcm for multiple numbers might require calculus, and also the runtime was super prolonged. Then I implemented divison brute force, which later took up to a minute to compute the lcm of 20 numbers, but was a fairly good program. Meanwhile, I found a faster program, which involved using lcm in Python 3.10. 

December 24th: 12:00 PM - 12:50 PM One Hour
I did problem 6 and started on seven today. Probem six involved heavy arithemic, which was quite easy with the help of a computer's CPU. I simply wrote the problem in terms of Python operations. The runtime was .1 seconds. I had a lot of troubles next problem, which needed precise variable assignments and multiple helper functions. I wrote a brute force program for the prime help function that detects whether or not a number is prime, and the thing simply views all numbers within the range of the original number, and sees whether or not they can be divided. It returns a boolean. Then, using a count variable, the 10001st prime number could be derived simply by ordered counting. However, the last part was the most difficult. Due to n adding +1 right before the function ends, the prime number was derailed by one. I did not notice this when I got a wrong submission page, and after a few more attempts, I realized and subtracted the answer by 1 to compensate. I needed the help of several Stack Overflow members in order to figure this out.Â 

December 25th: 12:00 PM - 12:57 PM One Hour
Today I worked on problems 8 and 9. Since the problems were slightly harder than before, I knew that I was going faster than before at coding. The eighth problem wanted to sort for the thirteen adjacent numbers that had the greatest product. Using a series of string to int conversions through lists, I was able to recreate the number in the format I wanted. I had trouble creating the readingframe that was supposed to shift by one every iteration, but later completed it with an int variable that was movable. I appended every product to a maxlist and then found the maximum product through a max() function. For the next problem, I had to create a function that satistied a set of equations. Using a layered for loop, the function iterated through every possible a and b value, consequently the c value. For every possible scenario, if the parameters satifisy the pythagorean theorem, the results were printed. The problem was not very hard, but it required a knowledge of layered loops and semi recursive functions. I spent the rest of the hour looking at similar problems online. 

December 27th: 4:00 PM - 5:00 PM One Hour
Number ten required the sum of all prime numbers under two million. Obviously, total brute force was not an option. I found something curious online: the Sieve of Eratosthenes, that computed all prime numbers efficiently with the help of a sieve-like function. The sieve eliminated all possible composite numbers by determining all the multiples of a prime number. Although I knew how the Sieve worked, I didn't find a way to implement it correctly. 30 minutes later, I decided to go with sets - most efficient method of calculations under two million - and booleans that first listed everything as prime, then found their multiples. It was a very clever way that DID NOT require prime calculations, with just the power of multiples from 2. All of the prime numbers were eventually summed, and the right answer was derived. 
