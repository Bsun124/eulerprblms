import numpy as np
import matplotlib as plt

                                                ##Solutions to Euler's Problems##

"""1 - If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000."""

total=0#Variable Setting (Java Would've Been Useful)
for i in range(1000): #setting range
    if i%3 == 0 or i%5 == 0: #If i is a multiple
        total=total+i  #total is added to
print(total)

"""2. Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."""
total = 0 #Set Variables
firstvalue = 1  #Initialize to 1
secondvalue = 1
sum = 0

while sum <= 4000000: #sum has to be above 4 million in order to stop the function
    if sum % 2 == 0: #Initializes the equation
        total += sum #Total of Fibonacci sequence
    firstvalue = secondvalue #Uses a temporary value to add together variables
    secondvalue = sum #secondvalue set to second Fibbonacci position
    sum = firstvalue + secondvalue #Recreate third value

print(total)

"""3. The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?"""
#One of the hardest functions I've made, partially inspired by a stackoverflow page (not plagarized)
largenumber = 600851475143 #value
iteration = 2
while iteration**2 < largenumber: #Square root of largenumber is the maximum number necessary to calculate
    while largenumber % iteration == 0: #Excludes undividable solutions
        largenumber = largenumber / iteration #Breaks down composite numbers
    iteration = iteration + 1 #Adds one to continue the loop

print(largenumber)

"""4. A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers."""
#sequencename[::-1] to reverse a sequence
def reverse(string):
    return string[::-1#Code Shorthand

#Boolean Function
def palindrome(string):
    string=str(string)#Just to confirm string status (Java defining feature would've been useful)
    list=[]
    for character in string:
        list.append(character) #way to store individual characters of string
    if len(string)%2==0 and len(string) != 0: #Makes sure that palindrome is possible
        indexposition=int(len(string)/2) #Finds the middle index position between the palindrome word
        if list[:indexposition]==reverse(list[indexposition:]): #determines palindrome or not
            return True
    elif len(string)%2!=0 or len(string) == 0:
        return False
#Works as a palindrome boolean

#Makes a reverse and palindrome function boolean first
firstlist=[] #multiple lists for storage and sorting purposes
secondlist=[]
products=[]
palindromes=[]
first=999 #Max three digit values
second=999

while first!=100: #I set a reasonable value to obtain the answer. No need to go through all 999*999 possibilities
    firstlist.append(first)
    first-=1
while second!=100:
    secondlist.append(second)
    second-=1

for i in firstlist: #Stacked listing
    for j in secondlist:
        result=i*j #product creation
        products.append(result) #adds to list of possibility: a simple brute force
for product in products: #Goes through every possible product
    if palindrome(product)==True:
        palindromes.append(product)#Appends true palindromes

print(max(palindromes))#prints the max value of the palindromes

"""5. 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"""
#answer:465585120 after running for a minute
for i in range(2520,10000000000):#Extreme Brute Force as one of the only solutions
    if i % 11 == 0 and\
    i % 12 == 0 and\ #and/ moves all of the code onto one line
    i % 13 == 0 and\
    i % 14 == 0 and\
    i % 15 == 0 and\ #only included larger numbers to save computing time
    i % 16 == 0 and\
    i % 17 == 0 and\
    i % 18 == 0 and\
    i % 19 == 0 and\
    i % 20 == 0:
        print(i) #prints composite solution
        break #breaks once completed


"""6. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."""\
total=0
sum=0
for number in range(1, 101):
    #iterables squared and added
    number**=2
    total+=number
    #This is the sum of the squares of the numbers
for number2 in range(1,101):
    #itereables summed and finally squared
    sum+=number2
sum**=2 #square of the sum
print(abs(total-sum))#abs()removes the negative sign

"""7. By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10 001st prime number?"""
countprime=0#Defined Variables
n=2
def prime(number): #Boolean Prime Function: Brute Force Style
    for factors in range(2, number):
        #lacks intelligence, but works in a reasonable amount of time anyways
        if number%factors==0:
            return False
            break#removes composite numbers
    return True #otherwise, True

while countprime!=10001:#while count is not equal to 10001st
    if prime(n)==True:#if n is prime
        countprime+=1 #Add one to the count
    n+=1 #adds one to the number variable then
print(n-1) #Due to the fact that countprime equals to 10001 after n+1, n-1 would counter the slight
#malfunction


"""8. The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?"""


number=['73167176531330624919225119674426574742355349194934'
'96983520312774506326239578318016984801869478851843'
'85861560789112949495459501737958331952853208805511'
'12540698747158523863050715693290963295227443043557'
'66896648950445244523161731856403098711121722383113'
'62229893423380308135336276614282806444486645238749'
'30358907296290491560440772390713810515859307960866'
'70172427121883998797908792274921901699720888093776'
'65727333001053367881220235421809751254540594752243'
'52584907711670556013604839586446706324415722155397'
'53697817977846174064955149290862569321978468622482'
'83972241375657056057490261407972968652414535100474'
'82166370484403199890008895243450658541227588666881'
'16427171479924442928230863465674813919123162824586'
'17866458359124566529476545682848912883142607690042'
'24219022671055626321111109370544217506941658960408'
'07198403850962455444362981230987879927244284909188'
'84580156166097919133875499200524063689912560717606'
'05886116467109405077541002256983155200055935729725'
'71636269561882670428252483600823257530420752963450']
#very long string connected by separate quotes

newlist=[]
maxlist=[]#Two lists
for largenumber in number:
    for digit in largenumber:
        digit=int(digit)
        newlist.append(digit)#Turns number into single list of int()
        #Translates the string into int(), by character

a=int(0)#predefine

while a+int(13)!=int(1000):#while loop to create repetition
    total=1
    for digits in newlist[a:a+int(13)]: #Creates a reading frame
        total*=digits #Brute force calculate all
        maxlist.append(total) #appends all values
    a+=int(1) #Shifts entire frame by one

print(max(maxlist))#Prints max product from maxlist

"""
9. A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

a^2 + b^2 = c^2
For example, 32 + 42 = 9 + 16 = 25 = 5^2.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
"""
import time#time for fun
start_time=time.time() #timed

for a in range(1, 1000):
    for b in range(1, 1000): #Layered for loops provides all Pythagorean situations
        c=1000-a-b #set condition
        if (a**2+b**2) == c**2:
            print(a*b*c) #if satisfies equation

end_time=time.time()
print(end_time-start_time)

"""
10. Find the sum of all the primes below two million.
"""

def primes_sieve(limit):#Prime Sieve for all prime numbers with sets
    not_prime = [False] * limit #Labels all numbers False first
    total=0
    for i in range(2, limit):#iteration with range
        if not_prime[i]:#Always runs on first iteration
            continue
        for f in range(i*2, limit, i):#Starts with number squared, to limit, by every multiple
            not_prime[f] = True #All of these gets labeled as not_prime

        total+=i #Summed

    return total

print(primes_sieve(2000000))
